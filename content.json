{"meta":{"title":"冰梨","subtitle":null,"description":null,"author":"rim-wood","url":"http://www.icepear.cn"},"pages":[{"title":"个人简介","date":"2018-03-26T12:50:35.615Z","updated":"2018-03-26T12:50:35.614Z","comments":true,"path":"about/index.html","permalink":"http://www.icepear.cn/about/index.html","excerpt":"","text":"&emsp;吴黎明，Rim·Wood，95后，本科毕业于湖南长沙大学，16年毕业从事儿童机器人行业，现在医疗血站领域从事java开发&emsp;本科研读软件工程专业-java方向。喜欢折腾，对新技术永远激情，永远热泪盈眶。"},{"title":"分类","date":"2017-10-09T03:04:58.294Z","updated":"2017-10-09T03:04:58.294Z","comments":true,"path":"categories/index.html","permalink":"http://www.icepear.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-09T03:04:58.295Z","updated":"2017-10-09T03:04:58.295Z","comments":true,"path":"tags/index.html","permalink":"http://www.icepear.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"接口安全策略","slug":"other/api-security","date":"2017-08-09T11:30:02.000Z","updated":"2018-04-20T07:07:22.324Z","comments":true,"path":"2017/08/09/other/api-security/","link":"","permalink":"http://www.icepear.cn/2017/08/09/other/api-security/","excerpt":"在做接口的时候，我们经常会对安全这方面进行考虑，包括认证授权，接口安全等方面，下面就介绍一种接口安全的设计，如果有什么其他好的设计，都可以在评论区提出交流","text":"在做接口的时候，我们经常会对安全这方面进行考虑，包括认证授权，接口安全等方面，下面就介绍一种接口安全的设计，如果有什么其他好的设计，都可以在评论区提出交流 背景为什么要对接口进行安全控制呢，主要是出于这几方面的因素 防伪装攻击 防篡改攻击 防重放攻击 防数据信息泄露 解决办法解决办法有很多，一般常见的做法是token校验然后加上HTTPS。针对这四种情况，假如接口没做任何安全策略是很容易被攻击的。对于第一种防伪装攻击，一般的接口都会带有token认证，可以过滤掉；对于第二种以及第三种，假如别人截获了请求，修改了参数，token机制是没办法做到安全的，所以有效的办法就是加密，加密的办法有很多。下面以图介绍我用的一种这种方法的步骤是 将请求参数（一般是json形式）加上约定好的salt进行AES加密，加密出来的是byte，一般用base64进行转码输出，也可做位偏移，得到一个加密字符串；然后加上后端的token，加上时间戳，进行MD5加密得到一个定长的sign字符串 将sign，toekn，时间戳，参数组成http请求去访问接口这样做的好处就是，针对第二三种攻击，别人拦击你的请求进行篡改，后端根据参数+约定好的salt进行AES加密再加上+token+时间戳进行MD5加密，与sign比对发现两个MD5不一致，就知道，肯定有人篡改了参数，就可以拒绝这样的请求。如果你不想参数直接暴露出来也可以进行AES加密传给后端。这样就可以避免第四种情况 总结以上都是自己的愚见，如果有更好的设计方法，欢迎交流学习","categories":[{"name":"security","slug":"security","permalink":"http://www.icepear.cn/categories/security/"}],"tags":[{"name":"api","slug":"api","permalink":"http://www.icepear.cn/tags/api/"},{"name":"security","slug":"security","permalink":"http://www.icepear.cn/tags/security/"}]},{"title":"go圣经阅读","slug":"other/gopl","date":"2017-08-09T10:30:02.000Z","updated":"2017-11-22T08:18:16.280Z","comments":true,"path":"2017/08/09/other/gopl/","link":"","permalink":"http://www.icepear.cn/2017/08/09/other/gopl/","excerpt":"学习一门新语言时，会有一种自然的倾向, 按照自己熟悉的语言的套路写新语言程序。学习Go语言的过程中，请警惕这种想法，尽量别这么做。我们会演示怎么写好Go语言程序，所以阅读了称之为《go圣经》这本书,并且利用思维导图的方式记录了重点。","text":"学习一门新语言时，会有一种自然的倾向, 按照自己熟悉的语言的套路写新语言程序。学习Go语言的过程中，请警惕这种想法，尽量别这么做。我们会演示怎么写好Go语言程序，所以阅读了称之为《go圣经》这本书,并且利用思维导图的方式记录了重点。","categories":[{"name":"go","slug":"go","permalink":"http://www.icepear.cn/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.icepear.cn/tags/go/"}]},{"title":"多线程高并发面试题（Multithreading & Concurrency）","slug":"concurrency/interview","date":"2017-06-10T11:30:02.000Z","updated":"2018-03-26T09:08:11.841Z","comments":true,"path":"2017/06/10/concurrency/interview/","link":"","permalink":"http://www.icepear.cn/2017/06/10/concurrency/interview/","excerpt":"线程是java面试问题中的热门话题之一，下面总结了一些Java多线程以及并发访问问题和答案，毕竟多线程和并发性都是并存的。","text":"线程是java面试问题中的热门话题之一，下面总结了一些Java多线程以及并发访问问题和答案，毕竟多线程和并发性都是并存的。 多线程和并发多线程Process和Thread之间的区别 进程是一个独立的运行环境，能够看做是一个程序或者应用，java运行环境运行作为一个简单的包含不同的类和程序的进程集。 而线程可以叫做一个轻量级的进程，线程可以看作是进程中的一个执行任务，线程需要较少的资源来创建并存在于进程中，线程共享进程资源 多线程编程的优点多线程编程可以并发的执行，提高性能，因为某些线程会等待获取某些资源所以cpu不会闲置，多线程共享堆内存，所以创建多线程比创建多进程要好，举个例子就是Servlets的性能要比CGI要好 用户线程和守护线程有什么不同首先都是线程，区别是用户线程dead后，JVM就会退出，不管是否还有守护线程，因为守护线程本来就是守护用户线程的，用户线程都死了，守护线程也没有存在的意义，所以JVM就退出了。还有就是守护线程创建的子线程也是守护线程 在java中怎么创建一个线程 通过实现Runnable接口，重写run方法，线程通过New Thread(new 线程类())的方式创建，通过调用start方法启动 通过extend一个Thread类，重写run方法，通过new 线程类()的方式创建，通过调用start方法启动我们可以直接调用run方法，像普通方法那样，但是这时，线程是没有启动的，只有通过start方法，线程才会启动如果你的类提供更多的功能，建议实现Runnable接口。毕竟java是多实现，单继承，所以优先Runnable 线程的生命周期有哪些创建，就绪，运行，阻塞，死亡这五种方式 当new出线程类时，线程处于创建状态 当调用start方法时，线程处于就绪状态 当run方法执行时，线程处于运行状态 当线程因为某些原因放弃cpu资源时，处于阻塞状态。直到重新进入就绪状态，才有机会再次运行 当线程run方法执行完了，或者运行过程中异常中断了，或者调用了stop方法，就会退出run方法，此时线程就死亡了 怎样理解线程的优先级每个线程都有优先级，通常优先级较高的线程在执行时优先，但这个要取决于操作系统相关的线程调度程序实现。我们可以定义线程的优先级，线程优先级是一个int，从1到10,1的优先级最低，10最高。但不能保证优先级较低的线程之前一定执行优先级较高的线程。 什么是线程调度和时间分片线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让的程序依赖于线程的优先级） 如何确保main（）是Java程序中最后完成的线程我们可以使用Thread join（）方法来确保在完成主函数之前程序创建的所有线程都已经死亡 线程间通信方式主要是通过线程间内存共享，通过类的wait(),notify(),notifyAll()方法进行，这些方法都应该在同步方法或同步块中调用。 怎么确保线程安全 同步是最简单也是最广泛的线程安全工具 使用java.util.concurrent.atomic下的Atomic Wrapper类，例如AtomicInteger 使用java.util.concurrent.locks包中的类 使用线程安全的集合类，也在java.util.concurrent中，例如ConcurrentHashMap 将volatile关键字与变量一起使用，使每个线程都从内存中读取数据，而不是从线程缓存中读取数据。 volatile 关键字当使用volatile 关键字定义变量时，所有的线程将从主内存中读取而不是从线程的本地缓存读取，这就能确保变量在多线程的情况下也是同步的 同步块和同步方法那个更好更倾向于同步块的写法，因为同步块可以指定minitor对象锁定，可控制粒度更小。而同步方法会锁定整个对象，并且如果类中有多个同步块，即使它们不相关，也会阻止它们执行并将它们置于等待状态 创建守护线程的方法通常创建守护线程用于对系统不重要的功能，例如记录线程或监事线程来捕获系统资源细节和状态，最好避免IO操作的守护线程可以用Thread.setDaemon(true) 创建 ThreadLocal是什么ThreadLocal用于创建线程的局部变量，对象的所有线程共享它的变量，所以这个变量不是线程安全的，可以使用线程同步来达到线程的目的，但是如果想避免同步，就可以使用ThreadLocal变量，每个线程都有自己的ThreadLocal变量互不影响，可以使用get/set方法来设置和获取值 什么是死锁，怎么分析和避免死锁死锁是指两个或以上的线程永远处于阻塞状态。分析死锁，可以通过查看应用程序的java Thread dump，可以通过jstack工具查看状态为阻塞的线程，然后查看它正在等待的锁定的资源，每个资源都有一个唯一的ID，我们可以使用它找到哪个线程已经在对象上持有锁有以下准则可以避免死锁 避免嵌套锁定，这是大部分死锁的情况，也就是说尽量不要在锁定资源a的情况下，又去锁定资源b 只锁定需要锁定的东西，你应该只获取必须处理的资源的锁，如果我们只对某一个字段感兴趣，那么我们应该只锁定该特定字段而不是完整对象 避免无限等待，如果线程a必须等待线程b完成，尽量不要用sleep去控制，而是使用threa.join串行执行 什么是线程池，如何创建线程池根据系统自身的环境情况，有效的限制执行线程的数量，使得运行效果达到最佳。线程主要是通过控制执行的线程的数量，超出数量的线程排队等候，等待有任务执行完毕，再从队列最前面取出任务执行。创建线程池的方式有多种 java.util.concurrent.Executors 提供了线程池的静态实现方法,但一般不推荐这种写法 newFixedThreadPool();创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue； newSingleThreadExecutor();将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue； newCachedThreadPool();将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。 newScheduledThreadPool(); 用于创建一个线程池，线程池中得线程能够周期性地执行给定的任务 ThreadPoolExecutor类提供了更完善的线程池创建构造方法 ScheduledExecutorService 类提供了定期执行任务线程池 并发什么是原子操作，java并发api中的原子类是什么原子操作在一个任务单元中执行，不受其他操作的干扰。原子操作在多线程环境中是必需的，以避免数据不一致。比如int++ 就不是一个原子操作，因为再多线程的情况下，某个线程执行了加1，但其他线程可能读的还是旧的值，就会导致错误的结果。为了解决这个问题，我们必须保证count的增量操作是院子的，我们可以使用同步来达到目的，但java1.5以后在java.util.concurrent.atomic提供了int和long的包装类，可以用来实现这个原子操作，没有使用同步，有兴趣的可以深入了解实现 java并发api中的Lock接口是什么？与synchronize相比，它有什么好处？Lock 借口提供了更多广泛的锁定操作比使用synchronized，Lock结构更加灵活，可以有完全不同的属性，并且可以关联多个条件对象Lock有以下优点 可以让线程更公平 可以使线程在等待一个锁定对象时响应中断 可以去尝试获取锁定，但如果无法获取锁定时，则会立即返回或在超时后返回 可以以不同的顺序获取或释放不同范围内的lock 谈谈ExcutorExcutor 是在jdk 1.5 引入的，通过java.util.concurrent.Executor接口Excutor 主要是根据一组执行策略规范调用，调度，执行和控制异步任务创建多个线程并且没有达到最大阈值的限制会导致应用程序耗尽堆内存，所以创建线程池是一个比较好的解决方案，应为有限的线程可以被集中和重用，而Excutor就是为了更好的创建线程池设计的 什么是BlockingQueue，怎么通过BlockingQueue实现一个生产者消费者模型java.util.concurrent.BlockingQueue 是一个阻塞队列，阻塞必然有两种情况， 当队列满了的时候，进行入列操作会被阻塞 当队列空的时候，出列操作会被阻塞阻塞队列是线程安全的，所有排队方法本质上都是原子性的，使用内部锁或其他形式的并发控制阻塞队列主要也是用于生产者消费者问题，负责生产的线程不断的制造新对象并插入到阻塞队列中，直到达到这个队列的上限值。队列达到上限值之后生产线程将会被阻塞，直到消费的线程对这个队列进行消费。同理，负责消费的线程不断的从队列中消费对象，直到这个队列为空，当队列为空时，消费线程将会被阻塞，除非队列中有新的对象被插入。 谈谈Callable和FutureCallable相当于Runnable的一个扩展，不同于Runnable的是Callable是个泛型参数化接口，并能返回线程的执行结果，而且能在无法正常计算时抛出异常。Callable并不像Runnable那样通过Thread的start方法就能启动实现类的run方法，通常是利用ExecutorService的submit方法去启动call方法自执行任务，而ExecutorService的submit又可以返回一个Future类型的结果，因此Callable通常也与Future一起使用，还有一种方式是使用FutureTask封装Callable再由Thread去启动。所以Callable的好处是异步执行，还能返回结果，结合Future还能判断任务状态，取消任务 谈谈FutureTaskFutureTask是Future接口基类的实现类，可以和Executors一起用于异步处理，大多数情况下很少使用FutureTask类，但如果我们想要覆盖Future类的某些方法，并且保留基本实现，它就变得非常方便。我们可以扩展这个类，根据需求覆盖一些方法 谈谈Concurrent Collection类通常Collection类是快速失败的，这意味着当一个线程在使用iterator便利时，去修改集合，这个iterator.next()操作将抛出ConcurrentModificationException异常。而Concurrent Collection则不会出现这个问题，因为它就是为多线程设计的主要的类包括 ConcurrentHashMap, CopyOnWriteArrayList 和 CopyOnWriteArraySet 讲讲Executors类Executors 提供了很多静态使用方法，包括Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, 以及 Callable，所以可以使用executors类在java中轻松创建线程池，这也是唯一支持可调用实现执行的类。 java8中并发改进了哪些？重要的改进包括： ConcurrentHashMap 的compute(), forEach(), forEachEntry(), forEachKey(), forEachValue(), merge(), reduce() 和 search() 等方法 加入了CompletableFuture ，使异步编程更优美 Executors 新增了 newWorkStealingPool 线程池方法","categories":[{"name":"多线程","slug":"多线程","permalink":"http://www.icepear.cn/categories/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://www.icepear.cn/tags/多线程/"},{"name":"高并发","slug":"高并发","permalink":"http://www.icepear.cn/tags/高并发/"},{"name":"面试","slug":"面试","permalink":"http://www.icepear.cn/tags/面试/"}]},{"title":"jenkins 持续集成","slug":"jenkins/jenkins","date":"2017-04-10T10:30:02.000Z","updated":"2018-04-20T06:30:34.292Z","comments":true,"path":"2017/04/10/jenkins/jenkins/","link":"","permalink":"http://www.icepear.cn/2017/04/10/jenkins/jenkins/","excerpt":"持续集成是DevOps不可或缺的一部分，可以减少大量的部署操作。之所以选择jenkins，其重要原因可能在于其开源免费，接下来进行详细介绍","text":"持续集成是DevOps不可或缺的一部分，可以减少大量的部署操作。之所以选择jenkins，其重要原因可能在于其开源免费，接下来进行详细介绍 JenkinsWhat is Jenkins? Jenkins is a self-contained, open source automation server which can be used to automate all sorts of tasks related to building, testing, and deploying software. Jenkins can be installed through native system packages, Docker, or even run standalone by any machine with a Java Runtime Environment (JRE) installed. 官方给出了两点定义,大概的意思就是: jenkins 是一个独立的开源自动化服务器，可用于自动化与构建，测试和部署软件相关的各种任务。 Jenkins可以通过本机系统软件包安装，Docker，甚至可以通过安装Java Runtime Environment（JRE）的任何机器独立运行。 构建现在主要的这类软件，我都习惯使用docker进行部署，当然官方也说了可以直接使用jre，根据个人习惯选择。介绍三种方法: docker方式(推荐) 下载镜像 1docker pull jenkins 运行实例 1docker run -p 8080:8080 -p 50000:50000 jenkins 如果想挂载数据到宿主机，就先创建一个目录 1docker run -p 8080:8080 -p 50000:50000 -v /your/home:/var/jenkins_home jenkins 这只是简单的运行，并不能用于实际，后面会细说 jre运行下载,然后运行 1java -jar jenkins.war 官方方式 Ubuntu 1234wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'sudo apt-get updatesudo apt-get install jenkins centos 123sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.keyyum install jenkins 你也可以在/etc/sysconfig/jenkins中修改参数 12JENKINS_USER=\"root\"JENKINS_PORT=\"8008\" 设置完成之后，运行 1service jenkins start 如果能成功启动,那么恭喜你。像我就没这么轻松了，一脚下去几个坑，md，只能默默地填上。 坑1: 本以为可以成功,查看/etc/log/jenkins/jenkins.log发现端口占用导致错误,我X,docker那边没停占用了8008 顺带记录一下查看端口占用命令，老是忘 查看端口占用： 12 netstat -anp | grep 8008 或者 lsof -i:8008 查看应用占用： 1ps -aux | grep docker 坑2: 端口解决了，结果尼玛还是失败,发现启动脚本里面的java路径没设置 1vi /etc/init.d/jenkins 打开脚本发现 12345678candidates=\"/etc/alternatives/java/usr/lib/jvm/java-1.8.0/bin/java/usr/lib/jvm/jre-1.8.0/bin/java/usr/lib/jvm/java-1.7.0/bin/java/usr/lib/jvm/jre-1.7.0/bin/java/usr/bin/java\" 尼玛，还要配java路径,加上之后是可以启动了。 坑3 你以为启动了就ok了,简直是葫芦娃救爷爷，一个一个来。发现访问不了，于是乎怀疑是防火墙问题 打开端口后，终于正常了 上图 细说docker方式运行以docker方式运行，主要是快速方便。搭建docker形式需要注意几点 需要自己编写dockerfile，安装所需的一些工具 如果利用jenkins构建docker镜像，就要考虑是使用dockerIndocker还是dockerOutdocker 如果项目使用docker，可以考虑镜像私服，搭建方法可以参考下面详细针对这几点说明。 编写dockerfile是必要的，为什么这么说呢，因为避免不了要使用docker，jenkins使用docker有两种方式，一种是在dockerfile中再安装一个docker就是所谓的dockerIndocker，但是很多都不太推荐这种用法，大部分还是选择将宿主机的docker挂载至jenkins容器内运行。那既然能挂载那为什么还要写dockerfile呢，因为你宿主机跟jenkins镜像引入的基础镜像里自带的一些包都有些差异，毕竟镜像不可能像宿主机一样完整。像我用的centos，直接将docker挂进容器里面用，jenkins运行docker命令就会提示包不存在1docker: error while loading shared libraries: libltdl.so.7: cannot open shared object file: No such file or directory 后面找了一下，其实就是少包参考链接所以最终还是编写dockerfile，然后安装缺少的包假如宿主机docker 的权限是root，直接挂进jenkins容器还是会存在权限问题运行docker权限错误12Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock:Get http://%2Fvar%2Frun%2Fdocker.sock/v1.27/containers/json: dial unix /var/run/docker.sock: connect: permission denied 参考链接办法就是看宿主机docker用户的GID是多少，然后镜像中对应添加一致的，就可以愉快的在jenkins容器中使用docker了，我的dockerfile如下：1234567891011121314151617FROM jenkins:latestUSER rootARG DOCKER_GID=991RUN groupadd -g $&#123;DOCKER_GID&#125; dockerRUN apt-get update \\ &amp;&amp; apt-get install -y sudo libltdl-dev expect \\ &amp;&amp; rm -rf /var/lib/apt/lists/*RUN usermod -aG docker jenkinsRUN echo \"jenkins ALL=NOPASSWD: ALL\" &gt;&gt; /etc/sudoersUSER jenkins jenkins自动部署也少不了maven，jdk一系列插件，建议是直接挂在宿主机使用的，运行命令如下：docker run -p 8008:8080 -p 50000:50000 –add-host stpass-15.com:192.168.110.15 –name jenkins \\ -v /home/wulm/jenkins:/var/jenkins_home \\ -v /home/wulm/jdk1.8.0_131:/usr/java/jdk1.8.0_131 \\ -v /var/maven:/var/maven \\ -v /root/.ssh:/jenkins/.ssh \\ -v /usr/bin/docker:/usr/bin/docker:ro \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -d myjenkins:1.0（注：–add-host 是为了让容器dns能识别到内网私服库的域名）","categories":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.icepear.cn/categories/jenkins/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.icepear.cn/tags/jenkins/"},{"name":"持续集成","slug":"持续集成","permalink":"http://www.icepear.cn/tags/持续集成/"}]},{"title":"docker 私服库(V2)","slug":"other/docker-registry","date":"2017-04-09T10:30:02.000Z","updated":"2017-11-14T03:55:09.071Z","comments":true,"path":"2017/04/09/other/docker-registry/","link":"","permalink":"http://www.icepear.cn/2017/04/09/other/docker-registry/","excerpt":"搭建docker 私服库是持续集成的一部分，当然你可以使用公共库，但我更倾向于私服库，对团队内部来讲还是相当有益的，接下来详细记录如何搭建以及注意环节","text":"搭建docker 私服库是持续集成的一部分，当然你可以使用公共库，但我更倾向于私服库，对团队内部来讲还是相当有益的，接下来详细记录如何搭建以及注意环节 docker registry 搭建介绍registry是一种开源的,无状态，高度可扩展的服务器端应用程序，可存储和分发Docker映像。其实这些都是屁话，哈哈，只要了解私服库字面意思就知道是干嘛的了。V1就直接pass了，官方都抛弃了，直接用的是V2 搭建前提：先安装了docker，而且版本1.6以上 下载下载比较简单，通过docker下载镜像就行了1docker pull registry:2 简单运行下载之后，运行1docker run -d -p 5000:5000 --restart=always --name registry registry:2 这样一个私服库就跑起来了，但事实上这样基本上是没卵用的。官方文档说了A production-ready registry must be protected by TLS and should ideally use an access-control mechanism生产必须被TLS保护，合理的使用访问控制所以说了这么多其实没卵用，官方文档这么带我的，我也就这么写咯，所以还是看下面吧 安全运行 做TLS就要签名证书，所以第一步就是创建证书用openssl创建文件夹用于存放证书,也为了方便后续挂载至registry容器,官方也有1234$ mkdir -p certs$ openssl req \\ -newkey rsa:4096 -nodes -sha256 -keyout certs/domain.key \\ -x509 -days 365 -out certs/domain.crt 注意一定要输入CN（common name）之后的要用到(例如：myregistrydomain.com)创建之后，文件夹下就有两个文件：domain.crt domain.key 将证书添加至系统信任使用身份验证时，Docker的某些版本还要求在操作系统级别信任证书。centos:12$ cat certs/domain.crt » /etc/pki/tls/certs/ca-bundle.crt$ update-ca-trust ubuntu:12$ cp certs/domain.crt /usr/local/share/ca-certificates/myregistrydomain.com.crt$ update-ca-certificates 生成用户和密码光有TLS是不够的，还必须做到访问控制。实现访问限制的最简单方法是通过Native basic auth（这与其他Web服务器的基本身份验证机制非常相似）。 1234$ mkdir auth$ docker run \\ --entrypoint htpasswd \\ registry:2 -Bbn testuser testpassword &gt; auth/htpasswd 启动registry容器万事具备，只欠东风。现在只需要把容器启动起来，该挂载的挂载，改配的环境变量配上 12345678910111213docker run -d \\ -p 5000:5000 \\ --restart=always \\ --name registry \\ -v /home/docker-registry:/var/lib/registry \\ -v /home/wulm/auth:/auth \\ -e \"REGISTRY_AUTH=htpasswd\" \\ -e \"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\" \\ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\ -v /home/wulm/certs:/certs \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \\ -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \\ registry:2 至此registry算是搭建成功了，但是真的成没成功还得测试，最简单的是直接访问前提是这个域名写到了你的hosts文件 客户端docker测试 在另外一台主机上测试私服库是否可用，才能真正测试出正确性。 首先将myregistrydomain.com域名（也就是你配置的域名）对应的IP一起写到你的hosts文件中，以便系统能够根据域名找到私服 1vi /etc/hosts 在文件末尾添加一行 然后不管以什么方法，将私服库上的证书搞到测试机上来,并且写到docker认证的目录下（/etc/docker/certs.d/） 12mkdir -p /etc/docker/certs.d/myregistrydomain.com:5000 建一个文件夹cp /certs/domain.crt /etc/docker/certs.d/myregistrydomain.com:5000 然后将证书放到这个目录下（假设证书已经从私服库上拷下来放到/certs/domain.crt中） 建议是重启一下docker 1systemctl restart docker 这会假如你测试机上跑了其他容器，那这些肯定都是挂了的，一个一个起有太麻烦，所以可以用下面的命令批量重启一下 1docker start $(docker ps -a | awk '&#123; print $1&#125;' | tail -n +2) 就可以测试登录了 1docker login myregistrydomain.com:5000 不出意外输入账号密码，会提示登录成功。good luck","categories":[{"name":"docker","slug":"docker","permalink":"http://www.icepear.cn/categories/docker/"}],"tags":[{"name":"持续集成","slug":"持续集成","permalink":"http://www.icepear.cn/tags/持续集成/"},{"name":"docker","slug":"docker","permalink":"http://www.icepear.cn/tags/docker/"}]},{"title":"linux 防火墙配置","slug":"other/firewalld","date":"2017-03-21T10:30:02.000Z","updated":"2017-10-17T09:45:41.723Z","comments":true,"path":"2017/03/21/other/firewalld/","link":"","permalink":"http://www.icepear.cn/2017/03/21/other/firewalld/","excerpt":"目前大多情况都使用CentOs7，但Centos升级到7之后，内置的防火墙已经从iptables变成了firewalld。所以两个都记录一下。","text":"目前大多情况都使用CentOs7，但Centos升级到7之后，内置的防火墙已经从iptables变成了firewalld。所以两个都记录一下。 linux 防火墙配置firewalldCentos7默认安装了firewalld，如果没有安装的话，可以使用 yum install firewalld firewalld-config进行安装。 常用命令123456789101112启动防火墙 systemctl start firewalld 禁用防火墙 systemctl stop firewalld设置开机启动 systemctl enable firewalld停止并禁用开机启动 sytemctl disable firewalld重启防火墙 firewall-cmd --reload查看状态 systemctl status firewalld 或者 firewall-cmd --state 其他命令1234567891011121314151617181920212223查看版本 firewall-cmd --version查看帮助 firewall-cmd --help查看区域信息 firewall-cmd --get-active-zones查看指定接口所属区域信息 firewall-cmd --get-zone-of-interface=eth0拒绝所有包 firewall-cmd --panic-on取消拒绝状态 firewall-cmd --panic-off查看是否拒绝 firewall-cmd --query-panic将接口添加到区域(默认接口都在public) firewall-cmd --zone=public --add-interface=eth0(永久生效再加上 --permanent 然后reload防火墙)设置默认接口区域 firewall-cmd --set-default-zone=public(立即生效，无需重启)更新防火墙规则 firewall-cmd --reload 无需断开连接 或firewall-cmd --complete-reload 需要断开连接，类似重启服务 打开端口12345查看指定区域所有打开的端口 firewall-cmd --zone=public --list-ports在指定区域打开端口 firewall-cmd --zone=public --add-port=80/tcp --permanent 需要重启防火墙 说明：–zone 作用域–add-port=8080/tcp 添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效 iptables常用命令123456789开启防火墙(即时生效，重启后失效)：service iptables start关闭防火墙(即时生效，重启后失效)：service iptables stop开启防火墙(重启后永久生效)：chkconfig iptables on关闭防火墙(重启后永久生效)：chkconfig iptables off重启防火墙:service iptables restartd 打开、查看端口1/etc/init.d/iptables status 打开某个端口(以8080为例)12345iptables -A INPUT -p tcp --dport 8080 -j ACCEPT 打开/etc/rc.d/init.d/iptables save 保存/etc/init.d/iptables restart 重启 其他方式可以通过修改/etc/sysconfig/iptables文件的方式开启端口，运行1vi /etc/sysconfig/iptables 增加一行1-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT 参数说明: –A 参数就看成是添加一条规则–p 指定是什么协议，我们常用的tcp 协议，当然也有udp，例如53端口的DNS–dport 就是目标端口，当数据从外部进入服务器为目标端口–sport 数据从服务器出去，则为数据源端口使用–j 就是指定是 ACCEPT -接收 或者 DROP 不接收","categories":[{"name":"other","slug":"other","permalink":"http://www.icepear.cn/categories/other/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.icepear.cn/tags/linux/"},{"name":"防火墙","slug":"防火墙","permalink":"http://www.icepear.cn/tags/防火墙/"}]},{"title":"单例模式（Singleton pattern）","slug":"designpattern/singleton","date":"2017-03-15T10:30:00.000Z","updated":"2018-03-27T01:33:49.815Z","comments":true,"path":"2017/03/15/designpattern/singleton/","link":"","permalink":"http://www.icepear.cn/2017/03/15/designpattern/singleton/","excerpt":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。单例类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。单例类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 简介单例模式是常用的设计模式之一，在spring中也大量采用到，单例模式一般分为饿汉式和饱汉式这两种实现，但除了这两种其实还可以细分到线程安全领域，所以也就还会有线程安全的实现方式 基本定律 私有的静态实例变量 私有的构造方法 公共的获取实例的方法满足这三个条件，基本就可以写出单例了。下面详细分析几种写法 单例模式的写法饿汉式，最常见实现（可用）这种写法比较简单，而且一般来讲也是线程安全的，因为在类装载的时候就完成了实例化，避免同步问题 1234567public class Singleton&#123; private final static Singleton instance = new Singleton(); private Singleton(); public Singleton getInstance()&#123; return instance; &#125;&#125; 饿汉式，静态代码块（可用）和上面基本类似，只是把实例化的过程抽离到了静态代码块中 12345678910public class Singleton&#123; private static Singleton instance; static&#123; instance = new Singleton(); &#125; private Singleton(); public Singleton getInstance()&#123; return instance; &#125;&#125; 饿汉式，静态内部类，推荐这种方式跟上两种虽然都采用类加载机制来保证实例化时只有一个线程，但是上两种的做法是只要类被加载就会被实例化，假如这个类没有被用到，就会浪费内存。这种方式的好处就是起到了懒加载的效果，静态内部类在singleton类被加载时并不会立即实例化，而是在需要时实例化，调用getInstance才会去装载内部类 123456789101112public class Singleton&#123; private Singleton(); private static class SingletonInstance&#123; private static final Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonInstance.instance; &#125;&#125; 饱汉式，线程不安全（不可用）谈完饿汉再谈饱汉，饱汉一般的写法是，getInstance的时候我在实例化，当多个线程同时调用getInstance就会导致线程不安全12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 饱汉式，线程安全（可用，但效率低）那怎么可以达到线程安全呢，实现也很简单，不就是getInstance会导致同步问题嘛，那就加一个同步方法，但是也不太推荐这种做法，毕竟每次都要同步效率是很低的12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 饱汉式，线程安全升级（不可用）那同步效率低该怎么改进呢，于是想到就是静态代码块咯，效率会高一点吧123456789101112131415public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 这样就没问题了吗？仔细想想，假如在判断if (instance == null)时，另外一个线程也放好判断完了，两个线程还是会同时实例化 饱汉式，双重检查，线程安全，推荐这时双重检测是最完美不过的了，首先保证实例的原子性，然后双重判断，这样就不会出现实例化多个的情况了1234567891011121314151617public class Singleton &#123; //volatile 保证变量的原子性，都是从主线程内存中读取 private static volatile Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 枚举，推荐jdk1.5 引入枚举后，使用枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。123456public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/categories/设计模式/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://www.icepear.cn/tags/单例模式/"}]},{"title":"工厂模式（Factory Method）","slug":"designpattern/Factory","date":"2017-03-11T08:30:00.000Z","updated":"2017-10-16T08:57:22.038Z","comments":true,"path":"2017/03/11/designpattern/Factory/","link":"","permalink":"http://www.icepear.cn/2017/03/11/designpattern/Factory/","excerpt":"工厂模式是设计模式中比较基础也是比较常见的模式，一般用在创建对象上，所以属于创建型模式。工厂模式也分三种:简单工厂模式、工厂模式、抽象工厂模式。下面会对每个模式从解释、UML、代码进行详细说明","text":"工厂模式是设计模式中比较基础也是比较常见的模式，一般用在创建对象上，所以属于创建型模式。工厂模式也分三种:简单工厂模式、工厂模式、抽象工厂模式。下面会对每个模式从解释、UML、代码进行详细说明 工厂模式简单工厂模式解释简单工厂模式主要的意图就是抽象化实体类，让子类去决定实例化。在小米加步枪时代，你需要一辆马车，你需要自己去创造。而在飞机大炮时代，你需要一辆汽车，你就会找工厂造一台，如果需求再变通一点，甲需要宝马，乙需要奥迪。所以造车的工厂就要能造两种车，而简单工厂模式就符合这种需求。这个优点就是调用者创建对象只需通过工厂创建，扩展性高 UML图 示例代码Car接口基类123public interface Car&#123; void run();&#125; BMW类123456public class BMW implements Car&#123; @Override public void run() &#123; System.out.println(\"BMW is run!\"); &#125; &#125; AUTO类123456public class AUTO implements Car&#123; @Override public void run() &#123; System.out.println(\"AUTO is run!\"); &#125; &#125; 工厂类12345678910public class CarFactory&#123; public static BMW CreateBMW() &#123; return new BMW(); &#125; public static AUTO CreateAUTO() &#123; return new AUTO(); &#125;&#125; 具体调用123456789public class Test&#123; public static void main(String []args)&#123; BMW bmw = CarFactory.CreateBMW(); bmw.run(); AUTO auto = CarFactory.CreateAUTO(); auto.run(); &#125;&#125; 工厂模式解释工厂模式显然是对简单工厂模式的一种改进或者说是完善，遵循开闭原则。一个抽象工厂类派生出多个具体工厂类，具体工厂类只能生产对应的具体产品在现实需求中，宝马工厂和奥迪工厂肯定是不同的工厂，所以对工厂也进行抽象,这样就方便扩展了，当又来一种汽车时，只需要另外开辟一个工厂，而不要对原来工厂进行修改。 UML 示例代码Car接口基类123public interface Car&#123; void run();&#125; BMW类123456public class BMW implements Car&#123; @Override public void run() &#123; System.out.println(\"BMW is run!\"); &#125; &#125; AUTO类123456public class AUTO implements Car&#123; @Override public void run() &#123; System.out.println(\"AUTO is run!\"); &#125; &#125; 工厂抽象接口1234public interface CarFactory&lt;T&gt;&#123; T Create();&#125; BMW工厂类123456public class BMWFactory implements CarFactor&lt;BMW&gt;&#123; public BMW create() &#123; return new BMW(); &#125;&#125; AUTO工厂类12345public interface AUTOFactory implements CarFactor&lt;AUTO&gt;&#123; public AUTO create() &#123; return new AUTO(); &#125;&#125; 具体调用12345678public class Test&#123; public static void main(String []args)&#123; AUTOFactory autoFactory = new AUTOFactory(); AUTO auto = autoFactory.create(); auto.run(); &#125;&#125; 抽象工厂模式解释抽象工厂模式跟工厂模式最大的区别可能就是把产品再进行抽象，也就是一个抽象工厂类派生出多个具体工厂类，而具体工厂类可以生产出多个具体产品因为在现实生活中，很多产品都是一系列的，一个产品族。还按照上面的汽车的案例分析，现实生活中，你需要一台宝马，不可能说就是一种类型宝马，那宝马公司就去玩蛋蛋了，用户可能根据排量、汽车空间、稳定性、安全性各方面进行选择。所以宝马公司必须推出各个型号的子产品，例如3系和5系两款车，3系里面又包含1.5L排量的和2.0L排量的，5系同理。在实现这个需求上，我们就要对产品进行抽象，然后具体工厂写出对应的生产策略。 UML 示例代码3系BMW抽象类123456789public abstract class BMW320i&#123; //排量 private float displacement; public BMW320i(float displacement)&#123; this.displacement = displacement; &#125; public abstract void run(); //省略GET、SET&#125; 5系BMW抽象类123456789public abstract class BMW532i&#123; //排量 private float displacement; public BMW532i(float displacement)&#123; this.displacement = displacement; &#125; public abstract void run(); //省略GET、SET&#125; 1.5L的BMW3系类12345678public class BMW320i150 extends BMW320i&#123; public BMW320i150(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 320i\"); &#125;&#125; 2.0L的BMW3系类12345678public class BMW320i200 extends BMW320i&#123; public BMW320i200(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 320i\"); &#125;&#125; 1.5L的BMW5系类12345678public class BMW532i150 extends BMW532i&#123; public BMW532i150(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 532i\"); &#125;&#125; 2.0L的BMW5系类12345678public class BMW532i200 extends BMW532i&#123; public BMW532i200(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 532i\"); &#125;&#125; 工厂抽象接口1234public interface AbstractFactory &#123; public BMW320i createBMW320i(); public BMW532i createBMW532i();&#125; 1.5L抽象工厂类12345678910public class BMW150Factory implements AbstractFactory&#123; public BMW320i createBMW320i() &#123; return new BMW320i150(1.5f); &#125; public BMW532i createBMW532i() &#123; return new BMW532i150(1.5f); &#125;&#125; 2.0L抽象工厂类123456789public class BMW200Factory implements AbstractFactory &#123; public BMW320i createBMW320i() &#123; return new BMW320i200(2.0f); &#125; public BMW532i createBMW532i() &#123; return new BMW532i200(2.0f); &#125;&#125; 具体调用123456789101112131415public class test &#123; public static void main(String []args)&#123; BMW150Factory bmw150Factory = new BMW150Factory(); BMW200Factory bmw200Factory = new BMW200Factory(); BMW320i Bmw320i200 = bmw200Factory.createBMW320i(); BMW532i Bmw532i150 = bmw150Factory.createBMW532i(); Bmw320i200.run(); Bmw532i150.run(); /**结果：this is a 2.0L 320i * this is a 1.5L 532i */ &#125;&#125; 总结其实不管是工厂模式还是抽象工厂模式，其目的是一致的，就是利用抽象进行解耦，也没有必要说一定要在乎用工厂还是抽象工厂，完全要根据现实需求来确定方案。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/categories/设计模式/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"http://www.icepear.cn/tags/工厂模式/"}]},{"title":"设计模式（Design Pattern）","slug":"designpattern/DesignPattern","date":"2017-03-10T07:30:02.000Z","updated":"2017-10-16T08:57:18.742Z","comments":true,"path":"2017/03/10/designpattern/DesignPattern/","link":"","permalink":"http://www.icepear.cn/2017/03/10/designpattern/DesignPattern/","excerpt":"设计模式是前人通过不断实践总结出来的经验。在日常编码也时有用到，更多的体现是在各大框架设计里面。之前自己学习过，但没有通过自己总结出来，接下来，我将系统的总结设计模式，加深自己对设计模式的理解","text":"设计模式是前人通过不断实践总结出来的经验。在日常编码也时有用到，更多的体现是在各大框架设计里面。之前自己学习过，但没有通过自己总结出来，接下来，我将系统的总结设计模式，加深自己对设计模式的理解 设计模式分类一、创建型模式：1.工厂模式 2.抽象工厂模式 3.单例模式 4.建造者模式 5.原型模式 二、结构型模式1.适配器模式 2.桥接模式 3.过滤器模式 4.代理模式 5.组合模式 6.装饰器模式 7.外观模式 8.享元模式 三、行为型模式1.责任链模式 2.命令模式 3.解释器模式 4.迭代器模式 5.备忘录模式 6.中介者模式 7.观察者模式 8.状态模式 9.空对象模式 10.策略模式 11.模板方法模式 12.访问者模式 六大原则一、单一职责原则每个类的职责应该是单一的，不能让一个类负责做个业务。比如说:一个类负责职责A和职责B，当职责A的需求变更时，需要修改职责A的代码，可能会导致职责B的代码出现问题为了避免出现这样的问题，所以要一个类对应一个职责 二、开闭原则对扩展开放，对修改关闭比如说:一个创建水果的类，本来可以创建香蕉、西瓜两个水果。如果这个类要新加创建芒果的方法，就得对这个类进行修改，如果再加其他水果，又得对该类进行方法的新增。所以可以对香蕉、西瓜等水果进行抽象，创建水果的类只提供创建方法，要新加芒果时，只需要扩展一个芒果类即可，不需要对创建水果类进行修改。开闭原则的关键就在于抽象二字 三、里氏代换原则任何基类出现的地方，其子类也可以出现，替代其使用不会是出现错误换种方式说就是，我喜欢狗，所以我一定喜欢动物；但我喜欢动物，我不一定喜欢狗。里氏代换原则其实是对开闭原则的补充也就是抽象的具体实现，而实现需要注意的也就是抽象时需要注意的情况: 1. 子类必须实现父类的抽象方法，不能实现非抽象方法 2. 子类可以增加自己的方法 四、依赖倒置原则抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程 五、接口隔离原则使用多个专门的接口，而不使用单一的总接口比方说鸟和壁虎都属于动物，都实现动物接口，按理动物接口要包括飞行方法、爬行方法，但鸟类实现接口之后具有爬行方法、显然不合适。所以要拆分成，飞行动物接口和爬行动物接口。 六、迪米特原则(最少知道原则)一个软件实体应当尽可能少地与其他实体发生相互作用 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/tags/设计模式/"}]},{"title":"SpringBoot学习-基本使用","slug":"springboot/SpringBoot1","date":"2016-12-09T11:30:02.000Z","updated":"2017-10-16T08:57:51.188Z","comments":true,"path":"2016/12/09/springboot/SpringBoot1/","link":"","permalink":"http://www.icepear.cn/2016/12/09/springboot/SpringBoot1/","excerpt":"在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。","text":"在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。 使用SpringBoot开始废话不多讲，为什么使用SpringBoot，就一个字：“爽”。快速入门，精简配置，开箱即用，独立运行这些优点绝对会让你爱上它，当然最重要的一点就是微服务 构建项目使用maven构建，一般继承 spring-boot-starter-parent 项目来获取合适的默认设置只需要简单地设置 parent 为：12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 该父项目提供以下特性： 默认编译级别为Java 1.6 源码编码为UTF-8 一个依赖管理节点,允许你省略普通依赖的 标签,继承自 spring-boot-dependencies POM。 合适的资源过滤 合适的插件配置（ exec插件， surefire， Git commit ID， shade） 针对 application.properties 和 application.yml 的资源过滤改变属性可以使用 标签，例如123456&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;//项目编码格式 &lt;java.version&gt;1.8&lt;/java.version&gt;//改变java编译版本 &lt;docker.image.prefix&gt;willmin&lt;/docker.image.prefix&gt;//其他属性配置 &lt;docker.plugin.version&gt;0.4.12&lt;/docker.plugin.version&gt;&lt;/properties&gt; 打包插件让springboot应用独立运行，需要将应用导成可执行的jar，可以利用Spring Boot Maven插件，在中配置在pom中写入：12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 依赖项目列表在pom中可以轻易引用springboot的各种依赖，所有的starters遵循一个相似的命名模式： spring-boot-starter-* 是一种特殊类型的应用程序，该命名结构旨在帮你找到需要的starter。表 13.1. Spring Boot application starters 名称 描述 spring-boot-starter 核心Spring Boot starter， 包括自动配置支持， 日志和YAML spring-boot-starter-actuator 生产准备的特性， 用于帮你监控和管理应用 spring-boot-starter-amqp 对”高级消息队列协议”的支持， 通过 spring-rabbit 实现 spring-boot-starter-aop 对面向切面编程的支持， 包括 spring-aop 和AspectJ spring-boot-starter-test 对常用测试依赖的支持， 包括JUnit, Hamcrest和Mockito， 还有 spring-test 模块 spring-boot-starter-web 对全栈web开发的支持， 包括Tomcat和 spring-webmvc spring-boot-starter-websocket 对WebSocket开发的支持 spring-boot-starter-mail 对 javax.mail 的支持 spring-boot-starter-mobile 对 spring-mobile 的支持 spring-boot-starter-mustache 对Mustache模板引擎的支持 spring-boot-starter-redis 对REDIS键值数据存储的支持， 包括 spring-redis spring-boot-starter-security 对 spring-security 的支持 spring-boot-starter-jdbc 对JDBC数据库的支持 spring-boot-starter-data-jpa 对”Java持久化API”的支持， 包括 spring-data-jpa ， spring-orm 和Hibernate spring-boot-starter-data-rest 对通过REST暴露Spring Data仓库的支持， 通过 spring-data-rest-webmvc 实现 spring-boot-starter-thymeleaf 对Thymeleaf模板引擎的支持， 包括和Spring的集成 spring-boot-starter-velocity 对Velocity模板引擎的支持 spring-boot-starter-batch 对Spring Batch的支持， 包括HSQLDB数据库 spring-boot-starter-cloudconnectors 对Spring Cloud Connectors的支持， 简化在云平台下(例如，Cloud Foundry和Heroku)服务的连接 spring-boot-starter-dataelasticsearch 对Elasticsearch搜索和分析引擎的支持， 包括 spring-data-elasticsearch spring-boot-starter-datagemfire 对GemFire分布式数据存储的支持， 包括 spring-data-gemfire spring-boot-starter-datamongodb 对MongoDB NOSQL数据库的支持， 包括 spring-data-mongodb spring-boot-starter-data-solr 对Apache Solr搜索平台的支持， 包括 spring-data-solr spring-boot-starter-freemarker 对FreeMarker模板引擎的支持 spring-boot-starter-groovytemplates 对Groovy模板引擎的支持 spring-boot-starter-hateoas 对基于HATEOAS的RESTful服务的支持， 通过 spring-hateoas 实现 spring-boot-starter-hornetq 对”Java消息服务API”的支持， 通过HornetQ实现 spring-boot-starter-integration 对普通 spring-integration 模块的支持 spring-boot-starter-jersey 对Jersey RESTful Web服务框架的支持 spring-boot-starter-jtaatomikos 对JTA分布式事务的支持， 通过Atomikos实现 spring-boot-starter-jta-bitronix 对JTA分布式事务的支持， 通过Bitronix实现 spring-boot-starter-socialfacebook 对 spring-social-facebook 的支持 spring-boot-starter-sociallinkedin 对 spring-social-linkedin 的支持 spring-boot-starter-socialtwitter 对 spring-social-twitter 的支持 spring-boot-starter-ws 对Spring Web服务的支持 spring-boot-starter-jetty 导入Jetty HTTP引擎（ 作为Tomcat的替代） spring-boot-starter-log4j 对Log4J日志系统的支持 spring-boot-starter-logging 导入Spring Boot的默认日志系统（ Logback） spring-boot-starter-tomcat 导入Spring Boot的默认HTTP引擎（ Tomcat） 代码结构springboot应用并不要求任何特殊的代码结构，我一般是这么写的 1234567891011121314151617|-main |-java/com/icepear/项目名 |-web |-Controller |-service |-impl |-实现 |-接口 |-domain |-enums |-interfaces |-Repository.java |-实体.java |-docker |-Dockerfile |-resources |-application.yml","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.icepear.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.icepear.cn/tags/SpringBoot/"}]},{"title":"Markdown学习","slug":"other/Markdown","date":"2016-12-08T07:30:02.000Z","updated":"2017-10-17T08:12:53.817Z","comments":true,"path":"2016/12/08/other/Markdown/","link":"","permalink":"http://www.icepear.cn/2016/12/08/other/Markdown/","excerpt":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。","text":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 Markdown学习标题 #表示一级标题，##表示二级标题，多级标题依次累积 列表1.有序列表在文本前加入数字1.,2.,3.即可 1. 列表1 2. 列表2 2. 列表3 2.无序列表在文本前加入- - 列表1 - 列表2 - 列表3 注：-,1.和文本之间要保留一个字符的空格。 换行与缩进换行使用&lt;/br&gt;或者使用空行表示换行。缩进使用半方大的空白&amp;ensp;或&amp;#8194;也可以用全方大的空白&amp;emsp;或&amp;#8195;例如： &amp;ensp;你好&lt;/br&gt;&amp;emsp;世界 显示：&ensp;你好&emsp;世界 链接格式为:[文本](链接),例如 [google链接](https://www.google.com) 显示如：google链接 图片格式为：![](图片链接),例如 ![](http://g3.ykimg.com/0130391F4555C2DEFE9F592DF60A8431D4D237-366F-F0C2-ED67-4475501D05FC) 显示为： 分割线使用 * 三个星 * * * - - - 三个带空格的中划线 ___ 连续三个下划线 __________ 多个下划线 &lt;/pre&gt; 区块引用使用&gt;,例如 &gt; 你好&lt;/br&gt; &gt; 世界&lt;/br&gt; &gt; I`m coder 显示： 你好世界I`m coder 代码区块单句代码可以使用’ ` &#39;(也就是键盘~这个按钮)&lt;/br&gt; 区块使用标签和`嵌套，例如： `你好` &lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt; 显示如： 你好 这是一个代码区块。 粗体和斜体粗体的格式为**文本**，斜体的格式为*文本*例如: **你好**&lt;/br&gt; *世界* 显示:你好世界 表格格式如下: | dog | bird | cat | |---- |------|---- | | foo | foo | foo | | bar | bar | bar | | baz | baz | baz | 显示如下 dog bird cat foo foo foo bar bar bar baz baz baz 格式如下: | dog | bird | cat | |:----|:----:|----:| | foo | foo | foo | | bar | bar | bar | | baz | baz | baz | 显示如下 dog bird cat foo foo foo bar bar bar baz baz baz","categories":[{"name":"other","slug":"other","permalink":"http://www.icepear.cn/categories/other/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.icepear.cn/tags/Markdown/"}]}]}