{"meta":{"title":"冰梨","subtitle":null,"description":null,"author":"rim-wood","url":"http://www.icepear.cn"},"pages":[{"title":"分类","date":"2017-10-09T03:04:58.294Z","updated":"2017-10-09T03:04:58.294Z","comments":true,"path":"categories/index.html","permalink":"http://www.icepear.cn/categories/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2017-10-17T12:35:52.399Z","updated":"2017-10-17T12:35:52.399Z","comments":true,"path":"about/index.html","permalink":"http://www.icepear.cn/about/index.html","excerpt":"","text":"&emsp;本人吴黎明，猿名:Rim·Wood，生于1995年，本科毕业于湖南长沙大学，之前从事儿童机器人行业，现在医疗血站领域从事java开发&emsp;本科研读软件工程专业-java方向。喜欢折腾，对新技术永远激情，永远热泪盈眶。"},{"title":"标签","date":"2017-10-09T03:04:58.295Z","updated":"2017-10-09T03:04:58.295Z","comments":true,"path":"tags/index.html","permalink":"http://www.icepear.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jenkins 持续集成","slug":"jenkins/jenkins","date":"2017-04-10T10:30:02.000Z","updated":"2017-10-17T09:59:22.540Z","comments":true,"path":"2017/04/10/jenkins/jenkins/","link":"","permalink":"http://www.icepear.cn/2017/04/10/jenkins/jenkins/","excerpt":"持续集成是DevOps不可或缺的一部分，可以减少大量的部署操作。之所以选择jenkins，其重要原因可能在于其开源免费，接下来进行详细介绍","text":"持续集成是DevOps不可或缺的一部分，可以减少大量的部署操作。之所以选择jenkins，其重要原因可能在于其开源免费，接下来进行详细介绍 JenkinsWhat is Jenkins? Jenkins is a self-contained, open source automation server which can be used to automate all sorts of tasks related to building, testing, and deploying software. Jenkins can be installed through native system packages, Docker, or even run standalone by any machine with a Java Runtime Environment (JRE) installed. 官方给出了两点定义,大概的意思就是: jenkins 是一个独立的开源自动化服务器，可用于自动化与构建，测试和部署软件相关的各种任务。 Jenkins可以通过本机系统软件包安装，Docker，甚至可以通过安装Java Runtime Environment（JRE）的任何机器独立运行。 构建现在主要的这类软件，我都习惯使用docker进行部署，当然官方也说了可以直接使用jre，根据个人习惯选择。介绍三种方法: docker方式 下载镜像 1docker pull jenkins 运行实例 1docker run -p 8080:8080 -p 50000:50000 jenkins 如果想挂载数据到宿主机，就先创建一个目录 1docker run -p 8080:8080 -p 50000:50000 -v /your/home:/var/jenkins_home jenkins jre运行下载,然后运行 1java -jar jenkins.war 官方方式 Ubuntu 1234wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'sudo apt-get updatesudo apt-get install jenkins centos 123sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.keyyum install jenkins 你也可以在/etc/sysconfig/jenkins中修改参数 12JENKINS_USER=\"root\"JENKINS_PORT=\"8008\" 设置完成之后，运行 1service jenkins start 如果能成功启动,那么恭喜你。像我就没这么轻松了，一脚下去几个坑，md，只能默默地填上。 坑1: 本以为可以成功,查看/etc/log/jenkins/jenkins.log发现端口占用导致错误,我X,docker那边没停占用了8008 顺带记录一下查看端口占用命令，老是忘 查看端口占用： 12 netstat -anp | grep 8008 或者 lsof -i:8008 查看应用占用： 1ps -aux | grep docker 坑2: 端口解决了，结果尼玛还是失败,发现启动脚本里面的java路径没设置 1vi /etc/init.d/jenkins 打开脚本发现 12345678candidates=\"/etc/alternatives/java/usr/lib/jvm/java-1.8.0/bin/java/usr/lib/jvm/jre-1.8.0/bin/java/usr/lib/jvm/java-1.7.0/bin/java/usr/lib/jvm/jre-1.7.0/bin/java/usr/bin/java\" 尼玛，还要配java路径,加上之后是可以启动了。 坑3 你以为启动了就ok了,简直是葫芦娃救爷爷，坑一个一个来。发现访问不了，于是乎怀疑是防火墙问题 打开端口后，终于正常了，唉,不得不说docker还是强大 上图 插件 docker run -p 8008:8080 -p 50000:50000 –name jenkins \\ -v /home/wulm/jenkins:/var/jenkins_home \\ -v /data/jdk1.8.0_131:/usr/java/jdk1.8.0_131 \\ -v /var/maven/apache-maven-3.5.0:/var/maven/apache-maven-3.5.0 \\ -v /usr/bin/docker:/usr/bin/docker \\ -v /var/run/docker.sock:/var/run/docker.sock \\-d jenkins","categories":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.icepear.cn/categories/jenkins/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.icepear.cn/tags/jenkins/"},{"name":"持续集成","slug":"持续集成","permalink":"http://www.icepear.cn/tags/持续集成/"}]},{"title":"linux 防火墙配置","slug":"other/firewalld","date":"2017-03-21T10:30:02.000Z","updated":"2017-10-17T09:45:41.723Z","comments":true,"path":"2017/03/21/other/firewalld/","link":"","permalink":"http://www.icepear.cn/2017/03/21/other/firewalld/","excerpt":"目前大多情况都使用CentOs7，但Centos升级到7之后，内置的防火墙已经从iptables变成了firewalld。所以两个都记录一下。","text":"目前大多情况都使用CentOs7，但Centos升级到7之后，内置的防火墙已经从iptables变成了firewalld。所以两个都记录一下。 linux 防火墙配置firewalldCentos7默认安装了firewalld，如果没有安装的话，可以使用 yum install firewalld firewalld-config进行安装。 常用命令123456789101112启动防火墙 systemctl start firewalld 禁用防火墙 systemctl stop firewalld设置开机启动 systemctl enable firewalld停止并禁用开机启动 sytemctl disable firewalld重启防火墙 firewall-cmd --reload查看状态 systemctl status firewalld 或者 firewall-cmd --state 其他命令1234567891011121314151617181920212223查看版本 firewall-cmd --version查看帮助 firewall-cmd --help查看区域信息 firewall-cmd --get-active-zones查看指定接口所属区域信息 firewall-cmd --get-zone-of-interface=eth0拒绝所有包 firewall-cmd --panic-on取消拒绝状态 firewall-cmd --panic-off查看是否拒绝 firewall-cmd --query-panic将接口添加到区域(默认接口都在public) firewall-cmd --zone=public --add-interface=eth0(永久生效再加上 --permanent 然后reload防火墙)设置默认接口区域 firewall-cmd --set-default-zone=public(立即生效，无需重启)更新防火墙规则 firewall-cmd --reload 无需断开连接 或firewall-cmd --complete-reload 需要断开连接，类似重启服务 打开端口12345查看指定区域所有打开的端口 firewall-cmd --zone=public --list-ports在指定区域打开端口 firewall-cmd --zone=public --add-port=80/tcp --permanent 需要重启防火墙 说明：–zone 作用域–add-port=8080/tcp 添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效 iptables常用命令123456789开启防火墙(即时生效，重启后失效)：service iptables start关闭防火墙(即时生效，重启后失效)：service iptables stop开启防火墙(重启后永久生效)：chkconfig iptables on关闭防火墙(重启后永久生效)：chkconfig iptables off重启防火墙:service iptables restartd 打开、查看端口1/etc/init.d/iptables status 打开某个端口(以8080为例)12345iptables -A INPUT -p tcp --dport 8080 -j ACCEPT 打开/etc/rc.d/init.d/iptables save 保存/etc/init.d/iptables restart 重启 其他方式可以通过修改/etc/sysconfig/iptables文件的方式开启端口，运行1vi /etc/sysconfig/iptables 增加一行1-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT 参数说明: –A 参数就看成是添加一条规则–p 指定是什么协议，我们常用的tcp 协议，当然也有udp，例如53端口的DNS–dport 就是目标端口，当数据从外部进入服务器为目标端口–sport 数据从服务器出去，则为数据源端口使用–j 就是指定是 ACCEPT -接收 或者 DROP 不接收","categories":[{"name":"other","slug":"other","permalink":"http://www.icepear.cn/categories/other/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.icepear.cn/tags/linux/"},{"name":"防火墙","slug":"防火墙","permalink":"http://www.icepear.cn/tags/防火墙/"}]},{"title":"工厂模式（Factory Method）","slug":"designpattern/Factory","date":"2017-03-11T08:30:00.000Z","updated":"2017-10-16T08:57:22.038Z","comments":true,"path":"2017/03/11/designpattern/Factory/","link":"","permalink":"http://www.icepear.cn/2017/03/11/designpattern/Factory/","excerpt":"工厂模式是设计模式中比较基础也是比较常见的模式，一般用在创建对象上，所以属于创建型模式。工厂模式也分三种:简单工厂模式、工厂模式、抽象工厂模式。下面会对每个模式从解释、UML、代码进行详细说明","text":"工厂模式是设计模式中比较基础也是比较常见的模式，一般用在创建对象上，所以属于创建型模式。工厂模式也分三种:简单工厂模式、工厂模式、抽象工厂模式。下面会对每个模式从解释、UML、代码进行详细说明 工厂模式简单工厂模式解释简单工厂模式主要的意图就是抽象化实体类，让子类去决定实例化。在小米加步枪时代，你需要一辆马车，你需要自己去创造。而在飞机大炮时代，你需要一辆汽车，你就会找工厂造一台，如果需求再变通一点，甲需要宝马，乙需要奥迪。所以造车的工厂就要能造两种车，而简单工厂模式就符合这种需求。这个优点就是调用者创建对象只需通过工厂创建，扩展性高 UML图 示例代码Car接口基类123public interface Car&#123; void run();&#125; BMW类123456public class BMW implements Car&#123; @Override public void run() &#123; System.out.println(\"BMW is run!\"); &#125; &#125; AUTO类123456public class AUTO implements Car&#123; @Override public void run() &#123; System.out.println(\"AUTO is run!\"); &#125; &#125; 工厂类12345678910public class CarFactory&#123; public static BMW CreateBMW() &#123; return new BMW(); &#125; public static AUTO CreateAUTO() &#123; return new AUTO(); &#125;&#125; 具体调用123456789public class Test&#123; public static void main(String []args)&#123; BMW bmw = CarFactory.CreateBMW(); bmw.run(); AUTO auto = CarFactory.CreateAUTO(); auto.run(); &#125;&#125; 工厂模式解释工厂模式显然是对简单工厂模式的一种改进或者说是完善，遵循开闭原则。一个抽象工厂类派生出多个具体工厂类，具体工厂类只能生产对应的具体产品在现实需求中，宝马工厂和奥迪工厂肯定是不同的工厂，所以对工厂也进行抽象,这样就方便扩展了，当又来一种汽车时，只需要另外开辟一个工厂，而不要对原来工厂进行修改。 UML 示例代码Car接口基类123public interface Car&#123; void run();&#125; BMW类123456public class BMW implements Car&#123; @Override public void run() &#123; System.out.println(\"BMW is run!\"); &#125; &#125; AUTO类123456public class AUTO implements Car&#123; @Override public void run() &#123; System.out.println(\"AUTO is run!\"); &#125; &#125; 工厂抽象接口1234public interface CarFactory&lt;T&gt;&#123; T Create();&#125; BMW工厂类123456public class BMWFactory implements CarFactor&lt;BMW&gt;&#123; public BMW create() &#123; return new BMW(); &#125;&#125; AUTO工厂类12345public interface AUTOFactory implements CarFactor&lt;AUTO&gt;&#123; public AUTO create() &#123; return new AUTO(); &#125;&#125; 具体调用12345678public class Test&#123; public static void main(String []args)&#123; AUTOFactory autoFactory = new AUTOFactory(); AUTO auto = autoFactory.create(); auto.run(); &#125;&#125; 抽象工厂模式解释抽象工厂模式跟工厂模式最大的区别可能就是把产品再进行抽象，也就是一个抽象工厂类派生出多个具体工厂类，而具体工厂类可以生产出多个具体产品因为在现实生活中，很多产品都是一系列的，一个产品族。还按照上面的汽车的案例分析，现实生活中，你需要一台宝马，不可能说就是一种类型宝马，那宝马公司就去玩蛋蛋了，用户可能根据排量、汽车空间、稳定性、安全性各方面进行选择。所以宝马公司必须推出各个型号的子产品，例如3系和5系两款车，3系里面又包含1.5L排量的和2.0L排量的，5系同理。在实现这个需求上，我们就要对产品进行抽象，然后具体工厂写出对应的生产策略。 UML 示例代码3系BMW抽象类123456789public abstract class BMW320i&#123; //排量 private float displacement; public BMW320i(float displacement)&#123; this.displacement = displacement; &#125; public abstract void run(); //省略GET、SET&#125; 5系BMW抽象类123456789public abstract class BMW532i&#123; //排量 private float displacement; public BMW532i(float displacement)&#123; this.displacement = displacement; &#125; public abstract void run(); //省略GET、SET&#125; 1.5L的BMW3系类12345678public class BMW320i150 extends BMW320i&#123; public BMW320i150(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 320i\"); &#125;&#125; 2.0L的BMW3系类12345678public class BMW320i200 extends BMW320i&#123; public BMW320i200(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 320i\"); &#125;&#125; 1.5L的BMW5系类12345678public class BMW532i150 extends BMW532i&#123; public BMW532i150(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 532i\"); &#125;&#125; 2.0L的BMW5系类12345678public class BMW532i200 extends BMW532i&#123; public BMW532i200(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 532i\"); &#125;&#125; 工厂抽象接口1234public interface AbstractFactory &#123; public BMW320i createBMW320i(); public BMW532i createBMW532i();&#125; 1.5L抽象工厂类12345678910public class BMW150Factory implements AbstractFactory&#123; public BMW320i createBMW320i() &#123; return new BMW320i150(1.5f); &#125; public BMW532i createBMW532i() &#123; return new BMW532i150(1.5f); &#125;&#125; 2.0L抽象工厂类123456789public class BMW200Factory implements AbstractFactory &#123; public BMW320i createBMW320i() &#123; return new BMW320i200(2.0f); &#125; public BMW532i createBMW532i() &#123; return new BMW532i200(2.0f); &#125;&#125; 具体调用123456789101112131415public class test &#123; public static void main(String []args)&#123; BMW150Factory bmw150Factory = new BMW150Factory(); BMW200Factory bmw200Factory = new BMW200Factory(); BMW320i Bmw320i200 = bmw200Factory.createBMW320i(); BMW532i Bmw532i150 = bmw150Factory.createBMW532i(); Bmw320i200.run(); Bmw532i150.run(); /**结果：this is a 2.0L 320i * this is a 1.5L 532i */ &#125;&#125; 总结其实不管是工厂模式还是抽象工厂模式，其目的是一致的，就是利用抽象进行解耦，也没有必要说一定要在乎用工厂还是抽象工厂，完全要根据现实需求来确定方案。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/categories/设计模式/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"http://www.icepear.cn/tags/工厂模式/"}]},{"title":"《Effective Java》阅读记录","slug":"effectivejava/EffectiveJava","date":"2017-03-10T07:30:02.000Z","updated":"2017-10-16T08:58:16.259Z","comments":true,"path":"2017/03/10/effectivejava/EffectiveJava/","link":"","permalink":"http://www.icepear.cn/2017/03/10/effectivejava/EffectiveJava/","excerpt":"","text":"","categories":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://www.icepear.cn/categories/Effective-Java/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://www.icepear.cn/tags/Effective-Java/"}]},{"title":"设计模式（Design Pattern）","slug":"designpattern/DesignPattern","date":"2017-03-10T07:30:02.000Z","updated":"2017-10-16T08:57:18.742Z","comments":true,"path":"2017/03/10/designpattern/DesignPattern/","link":"","permalink":"http://www.icepear.cn/2017/03/10/designpattern/DesignPattern/","excerpt":"设计模式是前人通过不断实践总结出来的经验。在日常编码也时有用到，更多的体现是在各大框架设计里面。之前自己学习过，但没有通过自己总结出来，接下来，我将系统的总结设计模式，加深自己对设计模式的理解","text":"设计模式是前人通过不断实践总结出来的经验。在日常编码也时有用到，更多的体现是在各大框架设计里面。之前自己学习过，但没有通过自己总结出来，接下来，我将系统的总结设计模式，加深自己对设计模式的理解 设计模式分类一、创建型模式：1.工厂模式 2.抽象工厂模式 3.单例模式 4.建造者模式 5.原型模式 二、结构型模式1.适配器模式 2.桥接模式 3.过滤器模式 4.代理模式 5.组合模式 6.装饰器模式 7.外观模式 8.享元模式 三、行为型模式1.责任链模式 2.命令模式 3.解释器模式 4.迭代器模式 5.备忘录模式 6.中介者模式 7.观察者模式 8.状态模式 9.空对象模式 10.策略模式 11.模板方法模式 12.访问者模式 六大原则一、单一职责原则每个类的职责应该是单一的，不能让一个类负责做个业务。比如说:一个类负责职责A和职责B，当职责A的需求变更时，需要修改职责A的代码，可能会导致职责B的代码出现问题为了避免出现这样的问题，所以要一个类对应一个职责 二、开闭原则对扩展开放，对修改关闭比如说:一个创建水果的类，本来可以创建香蕉、西瓜两个水果。如果这个类要新加创建芒果的方法，就得对这个类进行修改，如果再加其他水果，又得对该类进行方法的新增。所以可以对香蕉、西瓜等水果进行抽象，创建水果的类只提供创建方法，要新加芒果时，只需要扩展一个芒果类即可，不需要对创建水果类进行修改。开闭原则的关键就在于抽象二字 三、里氏代换原则任何基类出现的地方，其子类也可以出现，替代其使用不会是出现错误换种方式说就是，我喜欢狗，所以我一定喜欢动物；但我喜欢动物，我不一定喜欢狗。里氏代换原则其实是对开闭原则的补充也就是抽象的具体实现，而实现需要注意的也就是抽象时需要注意的情况: 1. 子类必须实现父类的抽象方法，不能实现非抽象方法 2. 子类可以增加自己的方法 四、依赖倒置原则抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程 五、接口隔离原则使用多个专门的接口，而不使用单一的总接口比方说鸟和壁虎都属于动物，都实现动物接口，按理动物接口要包括飞行方法、爬行方法，但鸟类实现接口之后具有爬行方法、显然不合适。所以要拆分成，飞行动物接口和爬行动物接口。 六、迪米特原则(最少知道原则)一个软件实体应当尽可能少地与其他实体发生相互作用 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/tags/设计模式/"}]},{"title":"SpringBoot学习-基本使用","slug":"springboot/SpringBoot1","date":"2016-12-09T11:30:02.000Z","updated":"2017-10-16T08:57:51.188Z","comments":true,"path":"2016/12/09/springboot/SpringBoot1/","link":"","permalink":"http://www.icepear.cn/2016/12/09/springboot/SpringBoot1/","excerpt":"在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。","text":"在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。 使用SpringBoot开始废话不多讲，为什么使用SpringBoot，就一个字：“爽”。快速入门，精简配置，开箱即用，独立运行这些优点绝对会让你爱上它，当然最重要的一点就是微服务 构建项目使用maven构建，一般继承 spring-boot-starter-parent 项目来获取合适的默认设置只需要简单地设置 parent 为：12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 该父项目提供以下特性： 默认编译级别为Java 1.6 源码编码为UTF-8 一个依赖管理节点,允许你省略普通依赖的 标签,继承自 spring-boot-dependencies POM。 合适的资源过滤 合适的插件配置（ exec插件， surefire， Git commit ID， shade） 针对 application.properties 和 application.yml 的资源过滤改变属性可以使用 标签，例如123456&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;//项目编码格式 &lt;java.version&gt;1.8&lt;/java.version&gt;//改变java编译版本 &lt;docker.image.prefix&gt;willmin&lt;/docker.image.prefix&gt;//其他属性配置 &lt;docker.plugin.version&gt;0.4.12&lt;/docker.plugin.version&gt;&lt;/properties&gt; 打包插件让springboot应用独立运行，需要将应用导成可执行的jar，可以利用Spring Boot Maven插件，在中配置在pom中写入：12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 依赖项目列表在pom中可以轻易引用springboot的各种依赖，所有的starters遵循一个相似的命名模式： spring-boot-starter-* 是一种特殊类型的应用程序，该命名结构旨在帮你找到需要的starter。表 13.1. Spring Boot application starters 名称 描述 spring-boot-starter 核心Spring Boot starter， 包括自动配置支持， 日志和YAML spring-boot-starter-actuator 生产准备的特性， 用于帮你监控和管理应用 spring-boot-starter-amqp 对”高级消息队列协议”的支持， 通过 spring-rabbit 实现 spring-boot-starter-aop 对面向切面编程的支持， 包括 spring-aop 和AspectJ spring-boot-starter-test 对常用测试依赖的支持， 包括JUnit, Hamcrest和Mockito， 还有 spring-test 模块 spring-boot-starter-web 对全栈web开发的支持， 包括Tomcat和 spring-webmvc spring-boot-starter-websocket 对WebSocket开发的支持 spring-boot-starter-mail 对 javax.mail 的支持 spring-boot-starter-mobile 对 spring-mobile 的支持 spring-boot-starter-mustache 对Mustache模板引擎的支持 spring-boot-starter-redis 对REDIS键值数据存储的支持， 包括 spring-redis spring-boot-starter-security 对 spring-security 的支持 spring-boot-starter-jdbc 对JDBC数据库的支持 spring-boot-starter-data-jpa 对”Java持久化API”的支持， 包括 spring-data-jpa ， spring-orm 和Hibernate spring-boot-starter-data-rest 对通过REST暴露Spring Data仓库的支持， 通过 spring-data-rest-webmvc 实现 spring-boot-starter-thymeleaf 对Thymeleaf模板引擎的支持， 包括和Spring的集成 spring-boot-starter-velocity 对Velocity模板引擎的支持 spring-boot-starter-batch 对Spring Batch的支持， 包括HSQLDB数据库 spring-boot-starter-cloudconnectors 对Spring Cloud Connectors的支持， 简化在云平台下(例如，Cloud Foundry和Heroku)服务的连接 spring-boot-starter-dataelasticsearch 对Elasticsearch搜索和分析引擎的支持， 包括 spring-data-elasticsearch spring-boot-starter-datagemfire 对GemFire分布式数据存储的支持， 包括 spring-data-gemfire spring-boot-starter-datamongodb 对MongoDB NOSQL数据库的支持， 包括 spring-data-mongodb spring-boot-starter-data-solr 对Apache Solr搜索平台的支持， 包括 spring-data-solr spring-boot-starter-freemarker 对FreeMarker模板引擎的支持 spring-boot-starter-groovytemplates 对Groovy模板引擎的支持 spring-boot-starter-hateoas 对基于HATEOAS的RESTful服务的支持， 通过 spring-hateoas 实现 spring-boot-starter-hornetq 对”Java消息服务API”的支持， 通过HornetQ实现 spring-boot-starter-integration 对普通 spring-integration 模块的支持 spring-boot-starter-jersey 对Jersey RESTful Web服务框架的支持 spring-boot-starter-jtaatomikos 对JTA分布式事务的支持， 通过Atomikos实现 spring-boot-starter-jta-bitronix 对JTA分布式事务的支持， 通过Bitronix实现 spring-boot-starter-socialfacebook 对 spring-social-facebook 的支持 spring-boot-starter-sociallinkedin 对 spring-social-linkedin 的支持 spring-boot-starter-socialtwitter 对 spring-social-twitter 的支持 spring-boot-starter-ws 对Spring Web服务的支持 spring-boot-starter-jetty 导入Jetty HTTP引擎（ 作为Tomcat的替代） spring-boot-starter-log4j 对Log4J日志系统的支持 spring-boot-starter-logging 导入Spring Boot的默认日志系统（ Logback） spring-boot-starter-tomcat 导入Spring Boot的默认HTTP引擎（ Tomcat） 代码结构springboot应用并不要求任何特殊的代码结构，我一般是这么写的 1234567891011121314151617|-main |-java/com/icepear/项目名 |-web |-Controller |-service |-impl |-实现 |-接口 |-domain |-enums |-interfaces |-Repository.java |-实体.java |-docker |-Dockerfile |-resources |-application.yml","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.icepear.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.icepear.cn/tags/SpringBoot/"}]},{"title":"Markdown学习","slug":"other/Markdown","date":"2016-12-08T07:30:02.000Z","updated":"2017-10-17T08:12:53.817Z","comments":true,"path":"2016/12/08/other/Markdown/","link":"","permalink":"http://www.icepear.cn/2016/12/08/other/Markdown/","excerpt":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。","text":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 Markdown学习标题 #表示一级标题，##表示二级标题，多级标题依次累积 列表1.有序列表在文本前加入数字1.,2.,3.即可 1. 列表1 2. 列表2 2. 列表3 2.无序列表在文本前加入- - 列表1 - 列表2 - 列表3 注：-,1.和文本之间要保留一个字符的空格。 换行与缩进换行使用&lt;/br&gt;或者使用空行表示换行。缩进使用半方大的空白&amp;ensp;或&amp;#8194;也可以用全方大的空白&amp;emsp;或&amp;#8195;例如： &amp;ensp;你好&lt;/br&gt;&amp;emsp;世界 显示：&ensp;你好&emsp;世界 链接格式为:[文本](链接),例如 [google链接](https://www.google.com) 显示如：google链接 图片格式为：![](图片链接),例如 ![](http://g3.ykimg.com/0130391F4555C2DEFE9F592DF60A8431D4D237-366F-F0C2-ED67-4475501D05FC) 显示为： 分割线使用 * 三个星 * * * - - - 三个带空格的中划线 ___ 连续三个下划线 __________ 多个下划线 &lt;/pre&gt; 区块引用使用&gt;,例如 &gt; 你好&lt;/br&gt; &gt; 世界&lt;/br&gt; &gt; I`m coder 显示： 你好世界I`m coder 代码区块单句代码可以使用’ ` &#39;(也就是键盘~这个按钮)&lt;/br&gt; 区块使用标签和`嵌套，例如： `你好` &lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt; 显示如： 你好 这是一个代码区块。 粗体和斜体粗体的格式为**文本**，斜体的格式为*文本*例如: **你好**&lt;/br&gt; *世界* 显示:你好世界 表格格式如下: | dog | bird | cat | |---- |------|---- | | foo | foo | foo | | bar | bar | bar | | baz | baz | baz | 显示如下 dog bird cat foo foo foo bar bar bar baz baz baz 格式如下: | dog | bird | cat | |:----|:----:|----:| | foo | foo | foo | | bar | bar | bar | | baz | baz | baz | 显示如下 dog bird cat foo foo foo bar bar bar baz baz baz","categories":[{"name":"other","slug":"other","permalink":"http://www.icepear.cn/categories/other/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.icepear.cn/tags/Markdown/"}]}]}