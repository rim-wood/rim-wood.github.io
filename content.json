{"meta":{"title":"冰梨","subtitle":null,"description":null,"author":"rim-wood","url":"http://www.icepear.cn"},"pages":[{"title":"个人简介","date":"2017-10-09T03:04:58.293Z","updated":"2017-10-09T03:04:58.293Z","comments":true,"path":"about/index.html","permalink":"http://www.icepear.cn/about/index.html","excerpt":"","text":"&emsp;本人吴黎明，猿名:will-min，生于1995年，本科毕业于湖南长沙大学，现就职于深圳一家儿童陪伴机器人公司&emsp;高三毕业开始接触计算机编程,本科研读软件工程专业-java方向。喜欢折腾，对新技术永远激情，永远热泪盈眶。"},{"title":"分类","date":"2017-10-09T03:04:58.294Z","updated":"2017-10-09T03:04:58.294Z","comments":true,"path":"categories/index.html","permalink":"http://www.icepear.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-09T03:04:58.295Z","updated":"2017-10-09T03:04:58.295Z","comments":true,"path":"tags/index.html","permalink":"http://www.icepear.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"工厂模式（Factory Method）","slug":"Factory","date":"2017-03-11T08:30:00.000Z","updated":"2017-10-16T02:15:41.941Z","comments":true,"path":"2017/03/11/Factory/","link":"","permalink":"http://www.icepear.cn/2017/03/11/Factory/","excerpt":"工厂模式是设计模式中比较基础也是比较常见的模式，一般用在创建对象上，所以属于创建型模式。工厂模式也分三种:简单工厂模式、工厂模式、抽象工厂模式。下面会对每个模式从解释、UML、代码进行详细说明","text":"工厂模式是设计模式中比较基础也是比较常见的模式，一般用在创建对象上，所以属于创建型模式。工厂模式也分三种:简单工厂模式、工厂模式、抽象工厂模式。下面会对每个模式从解释、UML、代码进行详细说明 工厂模式简单工厂模式解释简单工厂模式主要的意图就是抽象化实体类，让子类去决定实例化。在小米加步枪时代，你需要一辆马车，你需要自己去创造。而在飞机大炮时代，你需要一辆汽车，你就会找工厂造一台，如果需求再变通一点，甲需要宝马，乙需要奥迪。所以造车的工厂就要能造两种车，而简单工厂模式就符合这种需求。这个优点就是调用者创建对象只需通过工厂创建，扩展性高 UML图 示例代码Car接口基类123public interface Car&#123; void run();&#125; BMW类123456public class BMW implements Car&#123; @Override public void run() &#123; System.out.println(\"BMW is run!\"); &#125; &#125; AUTO类123456public class AUTO implements Car&#123; @Override public void run() &#123; System.out.println(\"AUTO is run!\"); &#125; &#125; 工厂类12345678910public class CarFactory&#123; public static BMW CreateBMW() &#123; return new BMW(); &#125; public static AUTO CreateAUTO() &#123; return new AUTO(); &#125;&#125; 具体调用123456789public class Test&#123; public static void main(String []args)&#123; BMW bmw = CarFactory.CreateBMW(); bmw.run(); AUTO auto = CarFactory.CreateAUTO(); auto.run(); &#125;&#125; 工厂模式解释工厂模式显然是对简单工厂模式的一种改进或者说是完善，遵循开闭原则。一个抽象工厂类派生出多个具体工厂类，具体工厂类只能生产对应的具体产品在现实需求中，宝马工厂和奥迪工厂肯定是不同的工厂，所以对工厂也进行抽象,这样就方便扩展了，当又来一种汽车时，只需要另外开辟一个工厂，而不要对原来工厂进行修改。 UML 示例代码Car接口基类123public interface Car&#123; void run();&#125; BMW类123456public class BMW implements Car&#123; @Override public void run() &#123; System.out.println(\"BMW is run!\"); &#125; &#125; AUTO类123456public class AUTO implements Car&#123; @Override public void run() &#123; System.out.println(\"AUTO is run!\"); &#125; &#125; 工厂抽象接口1234public interface CarFactory&lt;T&gt;&#123; T Create();&#125; BMW工厂类123456public class BMWFactory implements CarFactor&lt;BMW&gt;&#123; public BMW create() &#123; return new BMW(); &#125;&#125; AUTO工厂类12345public interface AUTOFactory implements CarFactor&lt;AUTO&gt;&#123; public AUTO create() &#123; return new AUTO(); &#125;&#125; 具体调用12345678public class Test&#123; public static void main(String []args)&#123; AUTOFactory autoFactory = new AUTOFactory(); AUTO auto = autoFactory.create(); auto.run(); &#125;&#125; 抽象工厂模式解释抽象工厂模式跟工厂模式最大的区别可能就是把产品再进行抽象，也就是一个抽象工厂类派生出多个具体工厂类，而具体工厂类可以生产出多个具体产品因为在现实生活中，很多产品都是一系列的，一个产品族。还按照上面的汽车的案例分析，现实生活中，你需要一台宝马，不可能说就是一种类型宝马，那宝马公司就去玩蛋蛋了，用户可能根据排量、汽车空间、稳定性、安全性各方面进行选择。所以宝马公司必须推出各个型号的子产品，例如3系和5系两款车，3系里面又包含1.5L排量的和2.0L排量的，5系同理。在实现这个需求上，我们就要对产品进行抽象，然后具体工厂写出对应的生产策略。 UML 示例代码3系BMW抽象类123456789public abstract class BMW320i&#123; //排量 private float displacement; public BMW320i(float displacement)&#123; this.displacement = displacement; &#125; public abstract void run(); //省略GET、SET&#125; 5系BMW抽象类123456789public abstract class BMW532i&#123; //排量 private float displacement; public BMW532i(float displacement)&#123; this.displacement = displacement; &#125; public abstract void run(); //省略GET、SET&#125; 1.5L的BMW3系类12345678public class BMW320i150 extends BMW320i&#123; public BMW320i150(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 320i\"); &#125;&#125; 2.0L的BMW3系类12345678public class BMW320i200 extends BMW320i&#123; public BMW320i200(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 320i\"); &#125;&#125; 1.5L的BMW5系类12345678public class BMW532i150 extends BMW532i&#123; public BMW532i150(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 532i\"); &#125;&#125; 2.0L的BMW5系类12345678public class BMW532i200 extends BMW532i&#123; public BMW532i200(float displacement)&#123; super(displacement); &#125; public void run() &#123; System.out.printf(\"this is a\"+this.getDisplacement()+\"L 532i\"); &#125;&#125; 工厂抽象接口1234public interface AbstractFactory &#123; public BMW320i createBMW320i(); public BMW532i createBMW532i();&#125; 1.5L抽象工厂类12345678910public class BMW150Factory implements AbstractFactory&#123; public BMW320i createBMW320i() &#123; return new BMW320i150(1.5f); &#125; public BMW532i createBMW532i() &#123; return new BMW532i150(1.5f); &#125;&#125; 2.0L抽象工厂类123456789public class BMW200Factory implements AbstractFactory &#123; public BMW320i createBMW320i() &#123; return new BMW320i200(2.0f); &#125; public BMW532i createBMW532i() &#123; return new BMW532i200(2.0f); &#125;&#125; 具体调用123456789101112131415public class test &#123; public static void main(String []args)&#123; BMW150Factory bmw150Factory = new BMW150Factory(); BMW200Factory bmw200Factory = new BMW200Factory(); BMW320i Bmw320i200 = bmw200Factory.createBMW320i(); BMW532i Bmw532i150 = bmw150Factory.createBMW532i(); Bmw320i200.run(); Bmw532i150.run(); /**结果：this is a 2.0L 320i * this is a 1.5L 532i */ &#125;&#125; 总结其实不管是工厂模式还是抽象工厂模式，其目的是一致的，就是利用抽象进行解耦，也没有必要说一定要在乎用工厂还是抽象工厂，完全要根据现实需求来确定方案。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/categories/设计模式/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"http://www.icepear.cn/tags/工厂模式/"}]},{"title":"《Effective Java》阅读记录","slug":"EffectiveJava","date":"2017-03-10T07:30:02.000Z","updated":"2017-10-16T02:27:02.126Z","comments":true,"path":"2017/03/10/EffectiveJava/","link":"","permalink":"http://www.icepear.cn/2017/03/10/EffectiveJava/","excerpt":"","text":"","categories":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://www.icepear.cn/categories/Effective-Java/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"http://www.icepear.cn/tags/Effective-Java/"}]},{"title":"设计模式（Design Pattern）","slug":"DesignPattern","date":"2017-03-10T07:30:02.000Z","updated":"2017-10-16T02:25:12.097Z","comments":true,"path":"2017/03/10/DesignPattern/","link":"","permalink":"http://www.icepear.cn/2017/03/10/DesignPattern/","excerpt":"设计模式是前人通过不断实践总结出来的经验。在日常编码也时有用到，更多的体现是在各大框架设计里面。之前自己学习过，但没有通过自己总结出来，接下来，我将系统的总结设计模式，加深自己对设计模式的理解","text":"设计模式是前人通过不断实践总结出来的经验。在日常编码也时有用到，更多的体现是在各大框架设计里面。之前自己学习过，但没有通过自己总结出来，接下来，我将系统的总结设计模式，加深自己对设计模式的理解 设计模式分类一、创建型模式：1.工厂模式 2.抽象工厂模式 3.单例模式 4.建造者模式 5.原型模式 二、结构型模式1.适配器模式 2.桥接模式 3.过滤器模式 4.代理模式 5.组合模式 6.装饰器模式 7.外观模式 8.享元模式 三、行为型模式1.责任链模式 2.命令模式 3.解释器模式 4.迭代器模式 5.备忘录模式 6.中介者模式 7.观察者模式 8.状态模式 9.空对象模式 10.策略模式 11.模板方法模式 12.访问者模式 六大原则一、单一职责原则每个类的职责应该是单一的，不能让一个类负责做个业务。比如说:一个类负责职责A和职责B，当职责A的需求变更时，需要修改职责A的代码，可能会导致职责B的代码出现问题为了避免出现这样的问题，所以要一个类对应一个职责 二、开闭原则对扩展开放，对修改关闭比如说:一个创建水果的类，本来可以创建香蕉、西瓜两个水果。如果这个类要新加创建芒果的方法，就得对这个类进行修改，如果再加其他水果，又得对该类进行方法的新增。所以可以对香蕉、西瓜等水果进行抽象，创建水果的类只提供创建方法，要新加芒果时，只需要扩展一个芒果类即可，不需要对创建水果类进行修改。开闭原则的关键就在于抽象二字 三、里氏代换原则任何基类出现的地方，其子类也可以出现，替代其使用不会是出现错误换种方式说就是，我喜欢狗，所以我一定喜欢动物；但我喜欢动物，我不一定喜欢狗。里氏代换原则其实是对开闭原则的补充也就是抽象的具体实现，而实现需要注意的也就是抽象时需要注意的情况: 1. 子类必须实现父类的抽象方法，不能实现非抽象方法 2. 子类可以增加自己的方法 四、依赖倒置原则抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程 五、接口隔离原则使用多个专门的接口，而不使用单一的总接口比方说鸟和壁虎都属于动物，都实现动物接口，按理动物接口要包括飞行方法、爬行方法，但鸟类实现接口之后具有爬行方法、显然不合适。所以要拆分成，飞行动物接口和爬行动物接口。 六、迪米特原则(最少知道原则)一个软件实体应当尽可能少地与其他实体发生相互作用 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.icepear.cn/tags/设计模式/"}]},{"title":"SpringBoot学习-基本使用","slug":"SpringBoot1","date":"2016-12-09T11:30:02.000Z","updated":"2017-10-16T02:16:31.696Z","comments":true,"path":"2016/12/09/SpringBoot1/","link":"","permalink":"http://www.icepear.cn/2016/12/09/SpringBoot1/","excerpt":"在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。","text":"在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。 使用SpringBoot开始废话不多讲，为什么使用SpringBoot，就一个字：“爽”。快速入门，精简配置，开箱即用，独立运行这些优点绝对会让你爱上它，当然最重要的一点就是微服务 构建项目使用maven构建，一般继承 spring-boot-starter-parent 项目来获取合适的默认设置只需要简单地设置 parent 为：12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 该父项目提供以下特性： 默认编译级别为Java 1.6 源码编码为UTF-8 一个依赖管理节点,允许你省略普通依赖的 标签,继承自 spring-boot-dependencies POM。 合适的资源过滤 合适的插件配置（ exec插件， surefire， Git commit ID， shade） 针对 application.properties 和 application.yml 的资源过滤改变属性可以使用 标签，例如123456&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;//项目编码格式 &lt;java.version&gt;1.8&lt;/java.version&gt;//改变java编译版本 &lt;docker.image.prefix&gt;willmin&lt;/docker.image.prefix&gt;//其他属性配置 &lt;docker.plugin.version&gt;0.4.12&lt;/docker.plugin.version&gt;&lt;/properties&gt; 打包插件让springboot应用独立运行，需要将应用导成可执行的jar，可以利用Spring Boot Maven插件，在中配置在pom中写入：12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 依赖项目列表在pom中可以轻易引用springboot的各种依赖，所有的starters遵循一个相似的命名模式： spring-boot-starter-* 是一种特殊类型的应用程序，该命名结构旨在帮你找到需要的starter。表 13.1. Spring Boot application starters 名称 描述 spring-boot-starter 核心Spring Boot starter， 包括自动配置支持， 日志和YAML spring-boot-starter-actuator 生产准备的特性， 用于帮你监控和管理应用 spring-boot-starter-amqp 对”高级消息队列协议”的支持， 通过 spring-rabbit 实现 spring-boot-starter-aop 对面向切面编程的支持， 包括 spring-aop 和AspectJ spring-boot-starter-test 对常用测试依赖的支持， 包括JUnit, Hamcrest和Mockito， 还有 spring-test 模块 spring-boot-starter-web 对全栈web开发的支持， 包括Tomcat和 spring-webmvc spring-boot-starter-websocket 对WebSocket开发的支持 spring-boot-starter-mail 对 javax.mail 的支持 spring-boot-starter-mobile 对 spring-mobile 的支持 spring-boot-starter-mustache 对Mustache模板引擎的支持 spring-boot-starter-redis 对REDIS键值数据存储的支持， 包括 spring-redis spring-boot-starter-security 对 spring-security 的支持 spring-boot-starter-jdbc 对JDBC数据库的支持 spring-boot-starter-data-jpa 对”Java持久化API”的支持， 包括 spring-data-jpa ， spring-orm 和Hibernate spring-boot-starter-data-rest 对通过REST暴露Spring Data仓库的支持， 通过 spring-data-rest-webmvc 实现 spring-boot-starter-thymeleaf 对Thymeleaf模板引擎的支持， 包括和Spring的集成 spring-boot-starter-velocity 对Velocity模板引擎的支持 spring-boot-starter-batch 对Spring Batch的支持， 包括HSQLDB数据库 spring-boot-starter-cloudconnectors 对Spring Cloud Connectors的支持， 简化在云平台下(例如，Cloud Foundry和Heroku)服务的连接 spring-boot-starter-dataelasticsearch 对Elasticsearch搜索和分析引擎的支持， 包括 spring-data-elasticsearch spring-boot-starter-datagemfire 对GemFire分布式数据存储的支持， 包括 spring-data-gemfire spring-boot-starter-datamongodb 对MongoDB NOSQL数据库的支持， 包括 spring-data-mongodb spring-boot-starter-data-solr 对Apache Solr搜索平台的支持， 包括 spring-data-solr spring-boot-starter-freemarker 对FreeMarker模板引擎的支持 spring-boot-starter-groovytemplates 对Groovy模板引擎的支持 spring-boot-starter-hateoas 对基于HATEOAS的RESTful服务的支持， 通过 spring-hateoas 实现 spring-boot-starter-hornetq 对”Java消息服务API”的支持， 通过HornetQ实现 spring-boot-starter-integration 对普通 spring-integration 模块的支持 spring-boot-starter-jersey 对Jersey RESTful Web服务框架的支持 spring-boot-starter-jtaatomikos 对JTA分布式事务的支持， 通过Atomikos实现 spring-boot-starter-jta-bitronix 对JTA分布式事务的支持， 通过Bitronix实现 spring-boot-starter-socialfacebook 对 spring-social-facebook 的支持 spring-boot-starter-sociallinkedin 对 spring-social-linkedin 的支持 spring-boot-starter-socialtwitter 对 spring-social-twitter 的支持 spring-boot-starter-ws 对Spring Web服务的支持 spring-boot-starter-jetty 导入Jetty HTTP引擎（ 作为Tomcat的替代） spring-boot-starter-log4j 对Log4J日志系统的支持 spring-boot-starter-logging 导入Spring Boot的默认日志系统（ Logback） spring-boot-starter-tomcat 导入Spring Boot的默认HTTP引擎（ Tomcat） 代码结构springboot应用并不要求任何特殊的代码结构，我一般是这么写的 1234567891011121314151617|-main |-java/com/icepear/项目名 |-web |-Controller |-service |-impl |-实现 |-接口 |-domain |-enums |-interfaces |-Repository.java |-实体.java |-docker |-Dockerfile |-resources |-application.yml","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.icepear.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.icepear.cn/tags/SpringBoot/"}]},{"title":"Markdown学习","slug":"Markdown","date":"2016-12-08T07:30:02.000Z","updated":"2017-10-16T02:16:11.518Z","comments":true,"path":"2016/12/08/Markdown/","link":"","permalink":"http://www.icepear.cn/2016/12/08/Markdown/","excerpt":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。","text":"Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 Markdown学习标题 #表示一级标题，##表示二级标题，多级标题依次累积 列表1.有序列表在文本前加入数字1.,2.,3.即可 1. 列表1 2. 列表2 2. 列表3 2.无序列表在文本前加入- - 列表1 - 列表2 - 列表3 注：-,1.和文本之间要保留一个字符的空格。 换行与缩进换行使用&lt;/br&gt;或者使用空行表示换行。缩进使用半方大的空白&amp;ensp;或&amp;#8194;也可以用全方大的空白&amp;emsp;或&amp;#8195;例如： &amp;ensp;你好&lt;/br&gt;&amp;emsp;世界 显示：&ensp;你好&emsp;世界 链接格式为:[文本](链接),例如 [google链接](https://www.google.com) 显示如：google链接 图片格式为：![](图片链接),例如 ![](http://g3.ykimg.com/0130391F4555C2DEFE9F592DF60A8431D4D237-366F-F0C2-ED67-4475501D05FC) 显示为： 分割线使用 * 三个星 * * * - - - 三个带空格的中划线 ___ 连续三个下划线 __________ 多个下划线 &lt;/pre&gt; 区块引用使用&gt;,例如 &gt; 你好&lt;/br&gt; &gt; 世界&lt;/br&gt; &gt; I`m coder 显示： 你好世界I`m coder 代码区块单句代码可以使用’ ` &#39;(也就是键盘~这个按钮)&lt;/br&gt; 区块使用标签和`嵌套，例如： `你好` &lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt; 显示如： 你好 这是一个代码区块。 粗体和斜体粗体的格式为**文本**，斜体的格式为*文本*例如: **你好**&lt;/br&gt; *世界* 显示:你好世界 表格格式如下: | dog | bird | cat | |---- |------|---- | | foo | foo | foo | | bar | bar | bar | | baz | baz | baz | 显示如下 dog bird cat foo foo foo bar bar bar baz baz baz 格式如下: | dog | bird | cat | |:----|:----:|----:| | foo | foo | foo | | bar | bar | bar | | baz | baz | baz | 显示如下 dog bird cat foo foo foo bar bar bar baz baz baz","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.icepear.cn/categories/日常学习/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.icepear.cn/tags/Markdown/"}]}]}